type S = message: String

impl Print S with
    printne s = printne s.message

// If the compiler decides to pass by reference, the code becomes:
// void foo(const S *x, S *y) {
//    ...
// }
// which can mutate x when x == y if not careful
foo (x: S) (y: S) =
    printne "x before: "
    print x
    mut z = y
    z.!message := "modifying y"
    printne "x after:  "
    print x

mut x = S "original x string"
foo x x

// args: --delete-binary
// expected stderr:
// examples/codegen/pass_by_ref.an:15:15	error: Expected an unindent but found `:=`
//     z.!message := "modifying y"
// 
// examples/codegen/pass_by_ref.an:19:0	error: Expected a top-level item but found `mut`
// mut x = S "original x string"
// 
// examples/codegen/pass_by_ref.an:22:0	error: Expected `=` to begin the function body but found a newline
// // args: --delete-binary
// 
// examples/codegen/pass_by_ref.an:4:16	error: `printne` is not defined, was it a typo?
//     printne s = printne s.message
// 
// examples/codegen/pass_by_ref.an:12:4	error: `printne` is not defined, was it a typo?
//     printne "x before: "
// 
// examples/codegen/pass_by_ref.an:13:4	error: `print` is not defined, was it a typo?
//     print x
// 
// examples/codegen/pass_by_ref.an:15:4	error: `z` is not defined, was it a typo?
//     z.!message := "modifying y"

